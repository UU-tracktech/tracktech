"""Contains frame buffer class.

This program has been developed by students from the bachelor Computer Science at
Utrecht University within the Software Project course.
Â© Copyright Utrecht University (Department of Information and Computing Sciences)

"""
from collections import OrderedDict


class FrameBuffer:
    """Class that handles frame buffering logic and holds the buffer. The buffer maps frame_ids to a tuple
    of frame_obj and tracked_boxes, thus it contains frames and their tracked bounding boxes.

    """
    def __init__(self, size):
        """Set buffer size and initialize the dictionary.

        """
        self.__buffer_size = size
        self.__buffer = OrderedDict()

    def add_frame(self, frame, tracked_boxes):
        """Add a frame to the frame buffer.

        Args:
            frame (FrameObj): Frame object containing frame timestamp and frame np array.
            tracked_boxes (BoundingBoxes): Boxes generated by the tracking.
        """
        self.__buffer[frame.get_timestamp()] = (frame, tracked_boxes)
        # If the buffer exceeds the maximum size, pop its first element
        while len(self.__buffer) > self.__buffer_size:
            self.__buffer.popitem(last=False)

    def _get_element(self, frame_id):
        """Internal getter to get frame and bounding boxes given frame_id. Raises IndexError if the frame
        with the frame_id cannot be found in the buffer.

        Args:
            frame_id (float): Frame timestamp.

        Returns:
            (frame_obj, tracked_boxes): Frame and bounding boxes at the given timestamp.

        """
        if frame_id in self.__buffer:
            return self.__buffer[frame_id]

        raise IndexError("Frame not in buffer. Consider increasing the buffer size.")

    def get_frame(self, frame_id):
        """Returns the frame object for a given timestamp.

        Args:
            frame_id (float): Frame timestamp.

        Returns:
            (frame_obj): The frame object at the given timestamp.

        """
        frame, _ = self._get_element(frame_id)
        return frame

    def get_boxes(self, frame_id):
        """Returns the bounding boxes of a given frame.

        Args:
            frame_id (float): Frame timestamp.

        Returns:
            (BoundingBoxes): Boxes generated by the tracking at the given frame timestamp.
        """
        _, tracked_boxes = self._get_element(frame_id)
        return tracked_boxes

    def get_box(self, frame_id, box_id):
        """Returns the bounding box of a given frame and a box id.

        Args:
            frame_id (float): Frame timestamp.
            box_id (Int): Box number.

        Returns:
            (BoundingBox): Box generated by the tracking containing the box_id at the given frame timestamp.
        """
        _, tracked_boxes = self._get_element(frame_id)
        boxes = tracked_boxes.get_bounding_boxes()

        # Search for the box with the given box id in the bounding boxes list
        for box in boxes:
            if box.get_identifier() == box_id:
                return box

        raise ValueError("Box id was not found in the boxes list")

    @property
    def buffer(self):
        """Property for the buffer, used for testing

        Returns:
            (dict): The buffer object.
        """
        return self.__buffer
