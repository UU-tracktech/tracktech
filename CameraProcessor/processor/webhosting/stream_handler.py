"""File that displays the video stream on a localhost for testing with docker.

This program has been developed by students from the bachelor Computer Science at
Utrecht University within the Software Project course.
Â© Copyright Utrecht University (Department of Information and Computing Sciences)

"""

import time
import logging
import tornado.web
import tornado.gen
import cv2

import processor.utils.draw as draw
from processor.pipeline.process_frames import prepare_stream, process_stream

# Tornado example gotten from: https://github.com/wildfios/Tornado-mjpeg-streamer-python
# Combined with: https://github.com/wildfios/Tornado-mjpeg-streamer-python/issues/7


# pylint: disable=attribute-defined-outside-init
class StreamHandler(tornado.web.RequestHandler):
    """Streamhandler is for the tornado localhost page. It serves JPG images to the client

    Attributes:
        __previous_flush_timestamp (float): Timestamp of the previous flush
        __flush_interval (float): Time inbetween flushes
        __scaled_size (int, int): height, width target size of the image
    """
    @tornado.gen.coroutine
    def get(self):
        """Get request handler for the webpage to show video stream."""
        # Sets headers of the stream handler
        logging.info('set headers')
        self.set_header('Cache-Control',
                        'no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0')
        self.set_header('Pragma', 'no-cache')
        self.set_header('Content-Type', 'multipart/x-mixed-replace;boundary=--jpgboundary')
        self.set_header('Connection', 'close')

        # Timing of last flush
        self.__previous_flush_timestamp = time.time()

        # Every .1 seconds the buffer gets flushed
        self.__flush_interval = .1

        self.__scaled_size = None

        # Get the objects needed for process_stream and starts the function
        capture, detector, tracker, _ = prepare_stream()
        yield process_stream(capture, detector, tracker, self.__frame_processed)

        # Close capture and send response
        capture.close()
        self.finish()

    async def __frame_processed(self, frame_obj, detected_boxes, tracked_boxes):
        """When the frame got processed, this function gets called to put it in the buffer

        Args:
            frame_obj (FrameObj): Frame object containing the frame
            detected_boxes (BoundingBoxes): Boxes generated by the detection
            tracked_boxes (Boundingboxes): The tracked boxes from the frame processing loop
        """

        if self.__scaled_size is None:
            self.__calculate_scaled_size(frame_obj.get_frame().shape)

        scaled_frame = cv2.resize(frame_obj.get_frame(), self.__scaled_size)

        # Draw detections boxes
        detection_frame = frame_obj.get_frame().copy()
        draw.draw_detection_boxes(detection_frame, detected_boxes.get_bounding_boxes())
        detection_frame = cv2.resize(detection_frame, self.__scaled_size)

        # Draw tracking boxes
        tracking_frame = frame_obj.get_frame().copy()
        draw.draw_tracking_boxes(tracking_frame, tracked_boxes.get_bounding_boxes())
        tracking_frame = cv2.resize(tracking_frame, self.__scaled_size)

        # Tiled image
        img_tile = self.__concat_vh([[scaled_frame, detection_frame],
                                     [tracking_frame, scaled_frame]])

        # Encode the frame to jpg format
        ret, jpeg = cv2.imencode('.jpg', img_tile)

        # Frame was not retrieved
        if not ret:
            return

        img = jpeg.tobytes()

        # Write to the buffer
        try:
            self.write('--jpgboundary')
            self.write('Content-type: image/jpeg\r\n')
            self.write('Content-length: %s\r\n\r\n' % len(img))
            self.write(img)
        # Connection lost
        except RuntimeError as err:
            logging.error(f'Client disconnected, throwing the following error: {err}')

        # If it is time to flush the buffer again
        if self.__previous_flush_timestamp + self.__flush_interval < time.time():
            self.flush()
            self.__previous_flush_timestamp = time.time()

    def __calculate_scaled_size(self, shape):
        """Calculates the new shape of the image, downscaling dimentions that are too big

        Args:
            shape (int, int, int): height, width, depth of the frame
        """
        height, width, _ = shape

        # Downscale width at least to 900
        if width > 900:
            width_scaling = 900 / width
            width = width * width_scaling
            height = height * width_scaling

        # Downscale height to a maximum of 650
        if height > 430:
            height_scaling = 430 / height
            width = width * height_scaling
            height = height * height_scaling

        # Set scaled size
        self.__scaled_size = (int(width), int(height))

    def __concat_vh(self, list_2d):
        """Concatinates the frames using opencv

        Args:
            list_2d ([[numpy.ndarray]]): A 2d list of frames

        Returns:
            numpy.ndarray: Concatinated arrays
        """
        # return final image
        return cv2.vconcat([cv2.hconcat(list_h)
                            for list_h in list_2d])
