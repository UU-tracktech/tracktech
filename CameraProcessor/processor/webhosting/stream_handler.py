"""File that displays the video stream on a localhost for testing with docker.

This program has been developed by students from the bachelor Computer Science at
Utrecht University within the Software Project course.
Â© Copyright Utrecht University (Department of Information and Computing Sciences)

"""

import time
import logging
import tornado.web
import tornado.gen
import cv2

import processor.utils.display as display
from processor.pipeline.process_frames import prepare_stream, process_stream

# Tornado example gotten from: https://github.com/wildfios/Tornado-mjpeg-streamer-python
# Combined with: https://github.com/wildfios/Tornado-mjpeg-streamer-python/issues/7


# pylint: disable=attribute-defined-outside-init
class StreamHandler(tornado.web.RequestHandler):
    """Streamhandler is for the tornado localhost page. It serves JPG images to the client

    Attributes:
        configs (ConfigParser): configurations of the stream
        __previous_flush_timestamp (float): Timestamp of the previous flush
        __flush_interval (float): Time inbetween flushes
    """
    def initialize(self, configs):
        """Give the configurations when initializing the stream handler

        Args:
            configs (ConfigParser): configurations
        """
        self.configs = configs

    @tornado.gen.coroutine
    def get(self):
        """Get request handler for the webpage to show video stream."""
        # Sets headers of the stream handler
        logging.info('set headers')
        self.set_header('Cache-Control',
                        'no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0')
        self.set_header('Pragma', 'no-cache')
        self.set_header('Content-Type', 'multipart/x-mixed-replace;boundary=--jpgboundary')
        self.set_header('Connection', 'close')

        # Timing of last flush
        self.__previous_flush_timestamp = time.time()

        # Every .1 seconds the buffer gets flushed
        self.__flush_interval = .1

        # Get the objects needed for process_stream and starts the function
        capture, detector, tracker, _ = prepare_stream(self.configs)
        yield process_stream(capture, detector, tracker, self.__frame_processed, None)

        # Close capture and send response
        capture.close()
        self.finish()

    def __frame_processed(self, frame_obj, detected_boxes, tracked_boxes):
        """When the frame got processed, this function gets called to put it in the buffer

        Args:
            frame_obj (FrameObj): Frame object containing the frame
            detected_boxes (BoundingBoxes): Boxes generated by the detection
            tracked_boxes (Boundingboxes): The tracked boxes from the frame processing loop
        """

        img_tile = display.generate_tiled_image(frame_obj, detected_boxes, tracked_boxes)

        # Encode the frame to jpg format
        ret, jpeg = cv2.imencode('.jpg', img_tile)

        # Frame was not retrieved
        if not ret:
            return

        img = jpeg.tobytes()

        # Write to the buffer
        try:
            self.write('--jpgboundary')
            self.write('Content-type: image/jpeg\r\n')
            self.write('Content-length: %s\r\n\r\n' % len(img))
            self.write(img)
        # Connection lost
        except RuntimeError as err:
            logging.error(f'Client disconnected, throwing the following error: {err}')

        # If it is time to flush the buffer again
        if self.__previous_flush_timestamp + self.__flush_interval < time.time():
            self.flush()
            self.__previous_flush_timestamp = time.time()
